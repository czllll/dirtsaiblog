---
title: "九大服务架构性能优化方式"
description: "腾讯公众号一片关于性能优化的文章，面试中可能会遇到这些问题"
date: 2024-08-26
tags: ["blog-reading", "system design"]
---
> 原文链接：[链接](https://mp.weixin.qq.com/s/38rsvewtkkqxRLPad-P3_Q)

## 要点

* 原文主要讲了性能优化的9种常用方式

### 缓存

#### 缓存位置

* 根据请求路径：浏览器 -> 服务器 -> 数据库
* 浏览器
  * 可以通过 `Expires、Cache-Control、Last-Modified、Etag`等字段控制浏览器是否使用本地缓存
* 服务器
  * 中间件：redis等
* 数据库
  * 通常使用mysql，mysql会利用[[Bufferpool详解]]缓存数据页面

#### 缓存常见问题

##### 缓存雪崩

* 定义：指缓存中的大量数据同时失效或者过期，导致大量的请求直接读取到下游数据库，导致数据库瞬时压力过大
* 解决：将缓存数据设置的过期时间随机化

##### 缓存穿透

* 定义：指读取下游不存在的数据，导致缓存命中不了，每次都请求下游数据库
* 解决：使用布隆过滤器[布隆过滤器](https://segmentfault.com/a/1190000021136424)对不存在的数据进行过滤；或者在读取下游数据不存在时在缓存设置空值

##### 缓存击穿

* 定义：指某个热点数据在缓存中被删除或者过期，导致大量的热点请求同时请求数据库
* 解决：对于热点数据设置较长的过期时间或者利用[[分布式锁]]避免多个相同请求同时访问下游数据

##### 热点key

* 定义：热点key是指缓存中被频繁访问的key，导致缓存该key的分片或者redis访问量过高
* 解决：
  * 将可热点key分散存储到多个key上，例如将热点key+序列号的方式存储，不同key存储的值都是相同的，在访问时随机访问一个key，分散原来单key分片的压力
  * 还可以将key缓存到机器内存中，避免redis单节点压力过大

#### 缓存淘汰

* 通常采用随机、[[LRU算法]]或者LFU算法

#### 缓存数据一致性

* 保证缓存与数据库中数据一致
* 一般对于DB和缓存的操作有如下几种方式
  * 更新缓存->更新DB
  * 更新DB->更新缓存
  * **更新DB->删除缓存**(最常用)
  * 删除缓存->更新DB

##### 做法

* 延时双删
  * 做法：先删除缓存，后续更新数据库，休眠一会（一般是1s）再删除缓存
  * 例如：使用go中的channel实现简单延时队列
  * 原理：在两次删除缓存的时间间隙可以覆盖大部分的并发操作，避免在读写并发时的问题
    * 读线程读cache=null，请求DB=100
    * 写线程更新DB=99，并删除缓存（本就无）
    * 读线程更新cache=100。**造成数据不一致**
    * **采用双删**：写线程再次休眠一会后删除缓存，cache=null，保证下次读的时候又从DB读，数据一致
* 订阅DB的变更binlog[[mysql三大日志（binlog、redolog、undolog）]],数据更新只变更DB，通过消费DB的binlog，解析变更操作进行缓存变更，更新失败时不进行消息的提交，通过消息队列的充实机制实现最终一致性；简而言之即使用消息队列来保守地更新缓存

### 并行化处理

#### redis的并行

* redis 在6.0之前一直是单线程模型，主要利用[[epoll]]管理用户海量连接，实现简单，避免了锁的竞争和线程切换，但不能有效利用cpu多核资源
* 6.0版本引入了多线程模型
  * 将耗时的socket读取和解析操作由多个I/O并发完成，命令的执行仍然适用单线程

#### Mysql的并行

* 基于组提交的并行复制在5.7版本引入
  * 核心思想：当多个事务在主库上几乎同时提交时，从库可以将这些事务分配给不同的SQL线程进行并行处理。**主要用于优化事务的复制性能**
  * 数据流转：
    * 从库：IO线程（只有一个）从主库拉取binlog写入relaylog中；多个SQL线程同时从relaylog中读取事件（即log中的记录）并执行
* 基于行的并行复制在8.0版本引入
  * 实现方式：在Row-Based Replication (RBR)模式下，binlog记录的是行级别的变化，而不是SQL语句本身，每一行的修改都作为独立的事件记录

### 批量化处理

#### Redis的AOF涉及的批量化

* redis的持久化方式有RDB与AOF，其中AOF在执行命令写入内存后，会写入到AOF缓冲区，可以选择合适的时机将AOF缓冲区中的数据写入到磁盘中
* 刷新到磁盘的时间通过参数appendfsync控制有三个值always、everysec、no。
  * 其中always会在每次命令执行完都会刷新到磁盘来保证数据的可靠性；
  * everysec是每秒批量写入到磁盘，
  * no是不进行同步操作，由操作系统决定刷新到写回磁盘，当redis异常退出时存在丢数据的风险。
* AOF命令刷新到磁盘的时机会影响redis服务写入性能，通常配置为everysec批量写入到磁盘，来平衡写入性能和数据可靠性。

### 数据压缩合并

#### Redis的AOF重写

* 是什么？
  * 随着时间的推移，AOF文件可能会变得非常大。为了控制文件大小，Redis提供了AOF文件的重写功能（Rewrite）。在重写过程中，Redis会创建一个新的AOF文件，这个文件包含了生成当前数据集的最小命令集

### 无锁化

#### Redis

* 单线程避免锁的竞争

#### MySql的MVCC

* [[MVCC]]

### 顺序写

#### Mysql涉及到的顺序写

* innoDB采用B+树，[[innoDB引擎]]

### 分片化

### 避免请求

* Mysql查询减少回表操作
* web应用可以使用合并css和js文件等减少http请求
* 移动端多tab可以采用懒加载方式，只有用户切换到新的tab后才会发起请求

### 池化

* Mysql连接池

### 异步处理

* 服务性能优化，可以解耦非主流成操作到消息队列中做异步处理
* redis的bgsave，bgrewriteof就是分别用来异步保存RDB跟AOF文件的命令
* redis删除key
  * del命令是同步删除，直接释放内存，当遇到大key时，删除操作会让redis出现卡顿的问题，
  * unlink是异步删除的方式

## 思考

* 本文作者在举性能优化的例子是，基本都是从常用的中间件和编程语言中举例子，很有参考意义。而在之前的学习中常常会忽略这些东西或者压根没记住。。
